<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intermission Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the table and form elements */
        body {
            font-family: 'Inter', sans-serif;
        }
        table {
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid theme('colors.gray.300');
            padding: 0.75rem;
        }
        input[type="text"], select {
            @apply w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500;
        }
        /* Style for the remove button */
        .remove-button {
            @apply bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-200 ease-in-out;
        }
        /* Style for primary action buttons */
        .primary-button {
            @apply bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105;
        }
        /* Style for secondary action buttons */
        .secondary-button {
            @apply bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105;
        }
        /* Style for tab buttons */
        .tab-button {
            @apply px-4 py-3 text-base font-medium text-center rounded-t-xl border-b-2;
        }
        .tab-button.active {
            @apply text-blue-700 border-blue-700 bg-white;
        }
        .tab-button:not(.active) {
            @apply text-gray-600 hover:text-blue-600 hover:border-blue-300 border-transparent bg-gray-50;
        }
        /* Style for the main container */
        .main-container {
            @apply bg-white p-6 sm:p-8 md:p-10 rounded-xl shadow-2xl w-full max-w-4xl;
        }

        /* Styles for result tabs */
        .result-tab-button {
            @apply px-4 py-2 text-sm font-medium text-center border-b-2;
        }
        .result-tab-button.active {
            @apply text-blue-600 border-blue-600;
        }
        .result-tab-button:not(.active) {
            @apply text-gray-500 hover:text-gray-700 hover:border-gray-300 border-transparent;
        }
        .result-tab-content {
            @apply p-4 bg-gray-50 border border-gray-200 rounded-b-lg;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen flex items-center justify-center p-4 sm:p-6 md:p-8">
    <div class="main-container">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-800 mb-6">Intermission Calculator</h1>

        <!-- Tab Navigation -->
        <div class="flex border-b border-gray-200 mb-6 rounded-t-xl overflow-hidden">
            <button id="tab-calculator" class="tab-button active flex-1">Calculator</button>
            <button id="tab-film-management" class="tab-button flex-1">Filmbeheer</button>
        </div>

        <!-- Calculator Tab Content -->
        <div id="content-calculator" class="tab-content">
            <div class="mb-4">
                <label for="location-select" class="block text-gray-700 text-sm font-bold mb-2">Kies Locatie:</label>
                <select id="location-select" class="shadow appearance-none border rounded-md w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    <option value="none">-- Selecteer Locatie --</option>
                    <option value="harderwijk">Harderwijk (5 Zalen)</option>
                    <option value="lelystad">Lelystad (6 Zalen)</option>
                </select>
            </div>

            <div class="overflow-x-auto mb-6">
                <table id="movies-calculator" class="min-w-full bg-white rounded-lg shadow-md overflow-hidden">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider">Film</th>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider">Starttijd (HH:MM)</th>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider">Mogelijke Pauzes (min)</th>
                            <th class="text-center text-sm font-semibold text-gray-700 uppercase tracking-wider">Drukte</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Movie rows will be added here dynamically by JavaScript -->
                    </tbody>
                </table>
            </div>

            <div class="flex flex-col sm:flex-row justify-center sm:justify-start gap-4 mb-6">
                <button id="calculate" class="secondary-button w-full sm:w-auto">
                    Breedste Pauzes Berekenen
                </button>
            </div>

            <h2 class="text-xl font-semibold text-gray-700 mb-3">Resultaat:</h2>
            <!-- Output container for results, either single or multiple tabs -->
            <div id="output-wrapper" class="min-h-[80px] space-y-3">
                 <div id="output-tabs" class="hidden">
                    <div class="flex border-b border-gray-200 mb-4">
                        <!-- Result tab buttons will be injected here -->
                    </div>
                    <div id="output-tab-content-container" class="bg-gray-100 p-4 rounded-lg shadow-inner text-gray-800 overflow-auto">
                        <!-- Result tab content will be injected here -->
                    </div>
                </div>
                <div id="single-output-container" class="min-h-[80px] space-y-3 bg-gray-100 p-4 rounded-lg shadow-inner text-gray-800 overflow-auto">
                    <!-- Single result content will be injected here -->
                </div>
            </div>
        </div>

        <!-- Film Management Tab Content -->
        <div id="content-film-management" class="tab-content hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Filmbeheer</h2>
            <div class="overflow-x-auto mb-6">
                <table id="movies-manager" class="min-w-full bg-white rounded-lg shadow-md overflow-hidden">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider">Film Naam</th>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider">Pauze Opties (min)</th>
                            <th class="text-left text-sm font-semibold text-gray-700 uppercase tracking-wider"></th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Film management rows will be added here -->
                    </tbody>
                </table>
            </div>
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mt-6">
                <button id="add-film-manager" class="primary-button w-full sm:w-auto">Film Toevoegen</button>
                <div class="flex gap-4 w-full sm:w-auto">
                    <input type="file" id="import-file-input" accept=".json" class="hidden" onchange="importFilms(event)">
                    <button id="import-films-button" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 w-full sm:w-auto">
                        Films Importeren
                    </button>
                    <button id="export-films-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 w-full sm:w-auto">
                        Films Exporteren
                    </button>
                </div>
            </div>
             <p id="film-management-message" class="mt-4 text-sm text-gray-600"></p>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        // Stores all film data for management and use in calculator
        let filmData = [];

        // --- DOM Elements ---
        const tabCalculatorBtn = document.getElementById('tab-calculator');
        const tabFilmManagerBtn = document.getElementById('tab-film-management');
        const contentCalculator = document.getElementById('content-calculator');
        const contentFilmManager = document.getElementById('content-film-management');

        const calculatorTbody = document.querySelector('#movies-calculator tbody');
        const filmManagerTbody = document.querySelector('#movies-manager tbody');

        const locationSelect = document.getElementById('location-select');
        const calculateBtn = document.getElementById('calculate');
        const addFilmManagerBtn = document.getElementById('add-film-manager');
        const outputWrapper = document.getElementById('output-wrapper'); // Main output wrapper
        const outputTabsContainer = document.getElementById('output-tabs'); // Container for tabs
        const outputTabButtonsDiv = outputTabsContainer.querySelector('.flex'); // Div for tab buttons
        const outputTabContentContainer = document.getElementById('output-tab-content-container'); // Container for tab content
        const singleOutputContainer = document.getElementById('single-output-container'); // Container for single result

        const importFileInput = document.getElementById('import-file-input');
        const importFilmsButton = document.getElementById('import-films-button');
        const exportFilmsButton = document.getElementById('export-films-button');
        const filmManagementMessage = document.getElementById('film-management-message');

        const MIN_GAP_REQUIRED = 8; // Global minimum gap required between intermissions

        // --- Event Listeners ---
        tabCalculatorBtn.addEventListener('click', () => showTab('calculator'));
        tabFilmManagerBtn.addEventListener('click', () => showTab('film-management'));
        locationSelect.addEventListener('change', updateCalculatorRows);
        calculateBtn.addEventListener('click', calculate);
        addFilmManagerBtn.addEventListener('click', () => addFilmManagementRow());
        importFilmsButton.addEventListener('click', () => importFileInput.click()); // Trigger hidden file input
        exportFilmsButton.addEventListener('click', exportFilms);


        // --- Initialization ---
        // Add some default film data for demonstration
        filmData.push({ name: 'Film A', options: [30, 45, 60] });
        filmData.push({ name: 'Film B', options: [50, 65] });
        filmData.push({ name: 'Film C', options: [40, 55, 70] });
        filmData.push({ name: 'Film D', options: [35, 50] });
        filmData.push({ name: 'Film E', options: [45, 60] });
        filmData.push({ name: 'Film F', options: [55, 70] });


        // Set initial tab to calculator
        showTab('calculator');
        // Populate film manager table and then calculator rows (after data is ready)
        populateFilmManagementTable();
        // Initially set to Harderwijk for 5 rows
        locationSelect.value = 'harderwijk';
        updateCalculatorRows();


        // --- Tab Management Functions ---
        /**
         * Shows the selected tab and hides others.
         * @param {string} tabName - The name of the tab to show ('calculator' or 'film-management').
         */
        function showTab(tabName) {
            // Update active state for tab buttons
            tabCalculatorBtn.classList.toggle('active', tabName === 'calculator');
            tabFilmManagerBtn.classList.toggle('active', tabName === 'film-management');

            // Show/hide content divs
            contentCalculator.classList.toggle('hidden', tabName !== 'calculator');
            contentFilmManager.classList.toggle('hidden', tabName !== 'film-management');

            // If switching to film management, refresh its table
            if (tabName === 'film-management') {
                populateFilmManagementTable();
                filmManagementMessage.textContent = ''; // Clear message when opening tab
            } else if (tabName === 'calculator') {
                // If switching back to calculator, refresh dropdowns and rows
                updateCalculatorRows();
            }
        }

        // --- Film Management Functions ---

        /**
         * Adds a new row to the film management table for adding/editing film details.
         * @param {string} name - Default film name.
         * @param {string} options - Default comma-separated options string.
         */
        function addFilmManagementRow(name = '', options = '') {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td><input type="text" class="film-name-input" value="${name}" placeholder="Filmnaam" onchange="saveFilmData()"></td>
                <td><input type="text" class="film-options-input" placeholder="b.v. 45,60" value="${options}" onchange="saveFilmData()"></td>
                <td>
                    <button onclick="removeFilmManagementRow(this)" class="remove-button">Verwijderen</button>
                </td>
            `;
            filmManagerTbody.appendChild(tr);
            filmManagementMessage.textContent = ''; // Clear message on add
        }

        /**
         * Populates the film management table from the filmData array.
         */
        function populateFilmManagementTable() {
            filmManagerTbody.innerHTML = ''; // Clear existing rows
            filmData.forEach((film) => {
                addFilmManagementRow(film.name, film.options.join(','));
            });
        }

        /**
         * Saves the current state of the film management table to filmData.
         * This function should be called on input change or row removal.
         * It reconstructs the filmData array directly from the DOM to ensure accuracy.
         */
        function saveFilmData() {
            const rows = Array.from(filmManagerTbody.querySelectorAll('tr'));
            filmData = rows.map(row => {
                const nameInput = row.querySelector('.film-name-input');
                const optionsInput = row.querySelector('.film-options-input');
                return {
                    name: nameInput ? nameInput.value.trim() : '',
                    options: optionsInput ? optionsInput.value
                        .split(',')
                        .map(s => parseInt(s.trim(), 10))
                        .filter(n => !isNaN(n)) : []
                };
            }).filter(f => f.name && f.options.length > 0); // Only keep valid films with name and at least one option

            // Re-populate dropdowns in calculator tab if needed (e.g., if on that tab)
            if (!contentCalculator.classList.contains('hidden')) {
                populateMovieDropdowns();
            }
        }

        /**
         * Removes a film management row and updates filmData.
         * @param {HTMLElement} buttonElement - The remove button that was clicked.
         */
        function removeFilmManagementRow(buttonElement) {
            buttonElement.closest('tr').remove(); // Remove the row from DOM
            saveFilmData(); // Re-save data to update filmData array correctly
            filmManagementMessage.textContent = 'Film succesvol verwijderd.';
        }

        /**
         * Exports the current film data to a JSON file.
         */
        function exportFilms() {
            if (filmData.length === 0) {
                filmManagementMessage.textContent = 'Geen films om te exporteren.';
                return;
            }
            try {
                const dataStr = JSON.stringify(filmData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'intermission_films.json';
                document.body.appendChild(a); // Append to body is required for Firefox
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Clean up
                filmManagementMessage.textContent = 'Films succesvol geëxporteerd!';
            } catch (error) {
                filmManagementMessage.textContent = `Fout bij exporteren: ${error.message}`;
                console.error('Error exporting films:', error);
            }
        }

        /**
         * Imports film data from a selected JSON file.
         * @param {Event} event - The change event from the file input.
         */
        function importFilms(event) {
            const file = event.target.files[0];
            if (!file) {
                filmManagementMessage.textContent = 'Geen bestand geselecteerd.';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Basic validation to ensure imported data structure is an array of objects
                    if (Array.isArray(importedData) && importedData.every(item => typeof item === 'object' && item.name && Array.isArray(item.options))) {
                        filmData = importedData;
                        populateFilmManagementTable(); // Refresh the film management table
                        populateMovieDropdowns(); // Refresh calculator dropdowns
                        filmManagementMessage.textContent = 'Films succesvol geïmporteerd!';
                    } else {
                        filmManagementMessage.textContent = 'Ongeldig JSON-formaat voor films. Zorg ervoor dat het een array van objecten is met "name" en "options" velden.';
                    }
                } catch (error) {
                    filmManagementMessage.textContent = `Fout bij importeren: ${error.message}`;
                    console.error('Error importing films:', error);
                }
            };
            reader.onerror = () => {
                filmManagementMessage.textContent = 'Kon bestand niet lezen.';
                console.error('File reader error:', reader.error);
            };
            reader.readAsText(file);
             // Clear the input value to allow selecting the same file again if needed
            event.target.value = '';
        }

        // --- Calculator Tab Functions ---

        /**
         * Updates the number of movie rows in the calculator based on location selection.
         */
        function updateCalculatorRows() {
            const location = locationSelect.value;
            let rowCount = 0;
            if (location === 'harderwijk') {
                rowCount = 5;
            } else if (location === 'lelystad') {
                rowCount = 6;
            }

            // Clear current rows
            calculatorTbody.innerHTML = '';

            const hours = Array.from({ length: 12 }, (_, i) => String(10 + i).padStart(2, '0')); // 10 to 21
            const minutes = ['00', '15', '30', '45'];

            // Add new rows based on rowCount
            for (let i = 0; i < rowCount; i++) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>
                        <select class="movie-select" onchange="onMovieSelectChange(this)">
                            <option value="">-- Kies film --</option>
                            <!-- Options will be populated by populateMovieDropdowns() -->
                        </select>
                    </td>
                    <td>
                        <div class="flex gap-1">
                            <select class="hour-select w-1/2 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                                ${hours.map(h => `<option value="${h}">${h}</option>`).join('')}
                            </select>
                            <span class="p-2">:</span>
                            <select class="minute-select w-1/2 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                                ${minutes.map(m => `<option value="${m}">${m}</option>`).join('')}
                            </select>
                        </div>
                    </td>
                    <td><input type="text" class="options" placeholder="b.v. 45,60" readonly></td>
                    <td class="text-center">
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" class="busy-checkbox sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                            <span class="ml-2 text-sm font-medium text-gray-700">Drukte</span>
                        </label>
                    </td>
                `;
                calculatorTbody.appendChild(tr);
            }
            populateMovieDropdowns(); // Populate dropdowns for new rows
            outputWrapper.innerHTML = ''; // Clear output when location changes
        }

        /**
         * Populates all movie dropdowns in the calculator table with films from filmData.
         */
        function populateMovieDropdowns() {
            const movieSelects = calculatorTbody.querySelectorAll('.movie-select');
            movieSelects.forEach(selectElement => {
                const selectedValue = selectElement.value; // Remember the currently selected value

                selectElement.innerHTML = '<option value="">-- Kies film --</option>'; // Clear existing options
                filmData.forEach(film => {
                    const option = document.createElement('option');
                    option.value = film.name;
                    option.textContent = film.name;
                    selectElement.appendChild(option);
                });
                // Restore selected value if it still exists
                if (selectedValue && Array.from(selectElement.options).some(opt => opt.value === selectedValue)) {
                    selectElement.value = selectedValue;
                    onMovieSelectChange(selectElement); // Trigger change to update options field
                }
            });
        }

        /**
         * Handles change event on movie selection dropdowns.
         * Populates the 'options' input field with the selected film's intermission options.
         * @param {HTMLSelectElement} selectElement - The select element that triggered the change.
         */
        function onMovieSelectChange(selectElement) {
            const selectedFilmName = selectElement.value;
            const optionsInput = selectElement.closest('tr').querySelector('.options');
            const selectedFilm = filmData.find(f => f.name === selectedFilmName);

            if (selectedFilm) {
                optionsInput.value = selectedFilm.options.join(',');
            } else {
                optionsInput.value = '';
            }
        }

        /**
         * Parses the movie data from the calculator table rows.
         * @returns {Array<Object>} An array of movie objects.
         */
        function parseMovies() {
            const rows = Array.from(calculatorTbody.querySelectorAll('tr'));
            return rows.map(row => {
                const nameSelect = row.querySelector('.movie-select');
                const hourSelect = row.querySelector('.hour-select');
                const minuteSelect = row.querySelector('.minute-select');
                const optionsInput = row.querySelector('.options'); // Now read-only
                const busyCheckbox = row.querySelector('.busy-checkbox'); // Get busy checkbox

                const startTime = (hourSelect && minuteSelect) ? `${hourSelect.value}:${minuteSelect.value}` : '';

                return {
                    name: nameSelect ? nameSelect.value || 'Onbekende Film' : 'Onbekende Film',
                    start: startTime,
                    options: optionsInput ? optionsInput.value
                        .split(',')
                        .map(s => parseInt(s.trim(), 10))
                        .filter(n => !isNaN(n)) : [],
                    isBusy: busyCheckbox ? busyCheckbox.checked : false // Add isBusy property
                };
            }).filter(m => m.start && m.options.length); // Only include valid entries
        }

        /**
         * Converts a time string (HH:MM) to minutes.
         * @param {string} t - The time string.
         * @returns {number} The time in minutes.
         */
        function timeToMinutes(t) {
            const [h, m] = t.split(':').map(Number);
            return h * 60 + m;
        }

        /**
         * Converts minutes to a time string (HH:MM).
         * @param {number} min - The time in minutes.
         * @returns {string} The time string.
         */
        function minutesToTime(min) {
            const h = String(Math.floor(min / 60)).padStart(2, '0');
            const m = String(min % 60).padStart(2, '0');
            return `${h}:${m}`;
        }

        /**
         * Generates the HTML content for a single result option.
         * @param {Object} solution - The solution object containing combo, range, minGap, etc.
         * @returns {string} The HTML string for the result.
         */
        function generateResultHtml(solution) {
            const htmlParts = [];
            const sortedCombo = [...solution.combo].sort((a, b) => a.absolute - b.absolute);

            sortedCombo.forEach((intermission, i) => {
                htmlParts.push(`
                    <div class="bg-blue-50 p-3 rounded-md border border-blue-200">
                        <p class="font-semibold text-gray-800">${intermission.movie}: ${intermission.offset} min (${minutesToTime(intermission.absolute)})</p>
                        ${i < sortedCombo.length - 1 ?
                            `<p class="text-gray-600 text-sm pl-4">  &rarr; ${sortedCombo[i+1].absolute - intermission.absolute} min pauze tot de volgende</p>` : ''
                        }
                    </div>
                `);
            });

            htmlParts.push(`
                <div class="bg-gray-200 p-4 rounded-lg font-semibold text-gray-800">
                    <p>Totaal verschil tussen eerste en laatste pauzemoment: ${solution.range} min</p>
                    ${solution.minGap !== Infinity && solution.minGap !== 0 && sortedCombo.length > 1 ?
                        `<p>Minimale kloof tussen pauzes: ${solution.minGap} min</p>` : ''
                    }
                </div>
            `);
            return htmlParts.join('');
        }

        /**
         * Displays the results in tabs if multiple options, or a single result if perfect.
         * @param {Array<Object>} solutions - An array of solution objects to display.
         * @param {boolean} isPerfectSolutionFound - True if at least one perfect solution was found.
         */
        function displayResults(solutions, isPerfectSolutionFound) {
            // Clear previous output
            outputTabButtonsDiv.innerHTML = '';
            outputTabContentContainer.innerHTML = '';
            singleOutputContainer.innerHTML = '';

            if (isPerfectSolutionFound && solutions.length > 0) {
                // Display single best perfect solution
                outputTabsContainer.classList.add('hidden');
                singleOutputContainer.classList.remove('hidden');
                singleOutputContainer.innerHTML = generateResultHtml(solutions[0]);
            } else if (solutions.length > 0) {
                // Display top 3 solutions in tabs
                outputTabsContainer.classList.remove('hidden');
                singleOutputContainer.classList.add('hidden');

                const maxTabs = Math.min(solutions.length, 3); // Display max 3 tabs

                solutions.slice(0, maxTabs).forEach((solution, index) => {
                    // Create tab button
                    const button = document.createElement('button');
                    button.classList.add('result-tab-button');
                    button.dataset.tabId = `result-${index}`;
                    button.textContent = `Optie ${index + 1}`;
                    outputTabButtonsDiv.appendChild(button); // Append button before setting up its content

                    // Create tab content pane
                    const contentPane = document.createElement('div');
                    contentPane.id = `result-tab-pane-${index}`; // Ensure ID is set
                    contentPane.classList.add('result-tab-pane', 'min-h-[80px]', 'space-y-3');
                    contentPane.innerHTML = generateResultHtml(solution);
                    outputTabContentContainer.appendChild(contentPane); // Append content pane

                    button.addEventListener('click', () => {
                        // Remove active class from all buttons
                        outputTabButtonsDiv.querySelectorAll('.result-tab-button').forEach(btn => {
                            if (btn) btn.classList.remove('active'); // Defensive check
                        });
                        // Add active class to clicked button
                        if (button) button.classList.add('active'); // Defensive check
                        
                        // Hide all tab content
                        outputTabContentContainer.querySelectorAll('.result-tab-pane').forEach(pane => {
                            if (pane) pane.classList.add('hidden'); // Defensive check
                        });
                        // Show active tab content by directly using contentPane
                        if (contentPane) contentPane.classList.remove('hidden'); // Defensive check
                    });

                    // Set first tab as active by default
                    if (index === 0) {
                        button.click(); // Simulate click to show first tab
                    } else {
                        contentPane.classList.add('hidden');
                    }
                });
            } else {
                // No solutions found at all
                outputTabsContainer.classList.add('hidden');
                singleOutputContainer.classList.remove('hidden');
                singleOutputContainer.innerHTML = '<p class="text-gray-600">Geen combinatie gevonden die voldoet aan alle regels (inclusief "Drukte"-beperkingen).</p>';
            }
        }


        /**
         * Calculates the widest possible intermissions for the entered movies,
         * prioritizing solutions where all gaps are at least MIN_GAP_REQUIRED,
         * then maximizing overall range, then maximizing the minimum gap
         * between intermediate intermissions, and enforcing "Drukte" constraints.
         */
        function calculate() {
            const movies = parseMovies();
            outputWrapper.innerHTML = ''; // Clear previous output
            outputTabButtonsDiv.innerHTML = '';
            outputTabContentContainer.innerHTML = '';
            singleOutputContainer.innerHTML = '';


            if (movies.length === 0) {
                singleOutputContainer.innerHTML = '<p class="text-gray-600">Voer geldige filmdata in.</p>';
                outputTabsContainer.classList.add('hidden');
                singleOutputContainer.classList.remove('hidden');
                return;
            }

            // Prepare option sets for each movie, converting start times and offsets to absolute minutes
            const optionSets = movies.map(m => {
                const startMin = timeToMinutes(m.start);
                return m.options.map(off => ({
                    movie: m.name,
                    offset: off,
                    absolute: startMin + off,
                    isBusy: m.isBusy // Propagate the isBusy flag to each option
                }));
            }).filter(set => set.length > 0); // Filter out movies without valid options

            if (optionSets.length === 0) {
                 singleOutputContainer.innerHTML = '<p class="text-gray-600">Geen geldige pauze-opties gevonden voor de geselecteerde films.</p>';
                 outputTabsContainer.classList.add('hidden');
                 singleOutputContainer.classList.remove('hidden');
                 return;
            }

            const allCandidateSolutions = []; // Stores all valid (by busy rule) combinations

            /**
             * Recursive function to search for all valid combinations of intermissions.
             * @param {Array<Object>} combo - The current combination of intermissions being tested.
             * @param {number} idx - The current movie index being processed.
             */
            function search(combo, idx) {
                // Base case: if all movies have been processed
                if (idx === optionSets.length) {
                    const times = combo.map(c => c.absolute);
                    if (times.length === 0) return; // Skip if no times are available

                    const sortedCombo = [...combo].sort((a, b) => a.absolute - b.absolute); // Sort the combo to check gaps

                    // --- Hard "Drukte" constraint check (minimaal 8 minuten tussen busy films) ---
                    // If any film is marked as busy, and the gap to its neighbor is less than MIN_GAP_REQUIRED,
                    // this combination is invalid and discarded.
                    for (let i = 0; i < sortedCombo.length - 1; i++) {
                        const current = sortedCombo[i];
                        const next = sortedCombo[i + 1];
                        const gap = next.absolute - current.absolute;

                        if (gap < MIN_GAP_REQUIRED && (current.isBusy || next.isBusy)) {
                            return; // Discard this combination immediately if busy rule is violated
                        }
                    }

                    // --- Evaluate this combination for range, minGap, and global MIN_GAP_REQUIRED ---
                    const currentRange = sortedCombo[sortedCombo.length - 1].absolute - sortedCombo[0].absolute;
                    const currentMaxTime = sortedCombo[sortedCombo.length - 1].absolute;

                    let currentMinGap = Infinity;
                    let meetsAllMinGaps = true; // Flag for global 8-min rule check
                    if (sortedCombo.length > 1) {
                        for (let i = 0; i < sortedCombo.length - 1; i++) {
                            const gap = sortedCombo[i+1].absolute - sortedCombo[i].absolute;
                            if (gap < currentMinGap) {
                                currentMinGap = gap;
                            }
                            if (gap < MIN_GAP_REQUIRED) {
                                meetsAllMinGaps = false; // Fails global 8-min rule
                            }
                        }
                    } else {
                        currentMinGap = 0; // For single intermission, no gap
                    }

                    // Store this combination as a candidate solution
                    allCandidateSolutions.push({
                        combo: combo.slice(), // Store a copy
                        range: currentRange,
                        maxTime: currentMaxTime,
                        minGap: currentMinGap,
                        meetsAllMinGaps: meetsAllMinGaps // Record if it meets the global 8-min rule
                    });
                    return;
                }

                // Recursive step: iterate through options for the current movie
                for (const opt of optionSets[idx]) {
                    combo.push(opt);
                    search(combo, idx + 1);
                    combo.pop();
                }
            }

            // Start the search with an empty combination and the first movie index
            search([], 0);

            let bestPerfectSolution = null;
            const fallbackSolutions = []; // For top 3 if no perfect solution is found

            // 1. First, try to find the absolute best "perfect" solution (all gaps >= MIN_GAP_REQUIRED)
            const perfectSolutions = allCandidateSolutions.filter(s => s.meetsAllMinGaps);

            if (perfectSolutions.length > 0) {
                // Sort perfect solutions: maximize range, then maximize minGap, then minimize maxTime
                perfectSolutions.sort((a, b) => {
                    if (b.range !== a.range) return b.range - a.range;
                    if (b.minGap !== a.minGap) return b.minGap - a.minGap;
                    return a.maxTime - b.maxTime; // Minimize maxTime if range and minGap are equal
                });
                bestPerfectSolution = perfectSolutions[0];
            }

            // 2. If no perfect solution, or if we need fallback options, sort all candidates for top 3
            if (!bestPerfectSolution) {
                // Sort all candidate solutions (including those with smaller gaps)
                allCandidateSolutions.sort((a, b) => {
                    // Primary sort: maximize range
                    if (b.range !== a.range) return b.range - a.range;
                    // Secondary sort: maximize minGap
                    if (b.minGap !== a.minGap) return b.minGap - a.minGap;
                    // Tertiary sort: minimize maxTime
                    return a.maxTime - b.maxTime;
                });
                // Take up to top 3 for fallback display
                fallbackSolutions.push(...allCandidateSolutions.slice(0, Math.min(allCandidateSolutions.length, 3)));
            }

            // --- Display Results ---
            if (bestPerfectSolution) {
                displayResults([bestPerfectSolution], true); // Found a perfect solution
            } else if (fallbackSolutions.length > 0) {
                displayResults(fallbackSolutions, false); // No perfect solution, display top 3 best efforts
            } else {
                // No valid combinations found at all (even after busy check)
                singleOutputContainer.innerHTML = '<p class="text-gray-600">Geen combinatie gevonden die voldoet aan alle regels (inclusief "Drukte"-beperkingen).</p>';
                outputTabsContainer.classList.add('hidden');
                singleOutputContainer.classList.remove('hidden');
            }
        }
    </script>
</body>
</html>
